--- ./libgcrypt-1.9.2/cipher/rsa.c	2021-08-02 12:38:29.921489018 +0800
+++ ./libgcrypt-1.9.2/cipher/rsa2.c	2021-08-07 21:28:36.759465341 +0800
@@ -1076,16 +1076,7 @@
 {
   /* Remove superfluous leading zeroes from INPUT.  */
   mpi_normalize (input);
-
-  if (!skey->p || !skey->q || !skey->u)
-    {
-      secret_core_std (output, input, skey->d, skey->n);
-    }
-  else
-    {
-      secret_core_crt (output, input, skey->d, mpi_get_nlimbs (skey->n),
-                       skey->p, skey->q, skey->u);
-    }
+	secret_core_std (output, input, skey->d, skey->n);
 }
 
 
@@ -1478,8 +1469,10 @@
   rc = _gcry_pk_util_data_to_mpi (s_data, &data, &ctx);
   if (rc)
     goto leave;
-  if (DBG_CIPHER)
-    log_printmpi ("rsa_sign   data", data);
+
+	_gcry_sexp_dump(s_data);
+  log_printmpi ("rsa_sign   data", data);
+
   if (mpi_is_opaque (data))
     {
       rc = GPG_ERR_INV_DATA;
@@ -1492,27 +1485,16 @@
                            NULL);
   if (rc)
     goto leave;
-  if (DBG_CIPHER)
-    {
-      log_printmpi ("rsa_sign      n", sk.n);
-      log_printmpi ("rsa_sign      e", sk.e);
-      if (!fips_mode ())
-        {
-          log_printmpi ("rsa_sign      d", sk.d);
-          log_printmpi ("rsa_sign      p", sk.p);
-          log_printmpi ("rsa_sign      q", sk.q);
-          log_printmpi ("rsa_sign      u", sk.u);
-        }
-    }
+
+	log_printmpi ("rsa_sign      n", sk.n);
+	log_printmpi ("rsa_sign      e", sk.e);
+	log_printmpi ("rsa_sign      d", sk.d);
 
   /* Do RSA computation.  */
   sig = mpi_new (0);
-  if ((ctx.flags & PUBKEY_FLAG_NO_BLINDING))
-    secret (sig, data, &sk);
-  else
-    secret_blinded (sig, data, &sk, ctx.nbits);
-  if (DBG_CIPHER)
-    log_printmpi ("rsa_sign    res", sig);
+	secret (sig, data, &sk);
+
+	log_printmpi ("rsa_sign    res", sig);
 
   /* Check that the created signature is good.  This detects a failure
      of the CRT algorithm  (Lenstra's attack on RSA's use of the CRT).  */
@@ -1544,6 +1526,7 @@
   else
     rc = sexp_build (r_sig, NULL, "(sig-val(rsa(s%M)))", sig);
 
+	_gcry_sexp_dump(*r_sig);
 
  leave:
   _gcry_mpi_release (result);
@@ -1580,8 +1563,10 @@
   rc = _gcry_pk_util_data_to_mpi (s_data, &data, &ctx);
   if (rc)
     goto leave;
-  if (DBG_CIPHER)
-    log_printmpi ("rsa_verify data", data);
+
+	_gcry_sexp_dump(s_data);
+	log_printmpi ("rsa_verify data", data);
+
   if (mpi_is_opaque (data))
     {
       rc = GPG_ERR_INV_DATA;
@@ -1595,24 +1580,23 @@
   rc = sexp_extract_param (l1, NULL, "s", &sig, NULL);
   if (rc)
     goto leave;
-  if (DBG_CIPHER)
-    log_printmpi ("rsa_verify  sig", sig);
+
+	log_printmpi ("rsa_verify  sig", sig);
 
   /* Extract the key.  */
   rc = sexp_extract_param (keyparms, NULL, "ne", &pk.n, &pk.e, NULL);
   if (rc)
     goto leave;
-  if (DBG_CIPHER)
-    {
-      log_printmpi ("rsa_verify    n", pk.n);
-      log_printmpi ("rsa_verify    e", pk.e);
-    }
+
+	log_printmpi ("rsa_verify    n", pk.n);
+	log_printmpi ("rsa_verify    e", pk.e);
 
   /* Do RSA computation and compare.  */
   result = mpi_new (0);
   public (result, sig, &pk);
-  if (DBG_CIPHER)
-    log_printmpi ("rsa_verify  cmp", result);
+
+	log_printmpi ("rsa_verify  cmp", result);
+
   if (ctx.verify_cmp)
     rc = ctx.verify_cmp (&ctx, result);
   else
